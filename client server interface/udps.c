//                                          compiling - gcc -g UDP_S.o -o UDP_S#include <sys/types.h>#include <sys/socket.h>#include <arpa/inet.h>#include <netinet/in.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#define DST_IP "239.0.0.1"#define DST_PORT 6000typedef struct{	int sd;	FILE *songFD;	char *songName;	int numOfStation;	//listener list[100];}station;struct in_addr iaddr;struct sockaddr_in saddr;struct timespec waitTime;int sd,i,numOfFrames,len;int fileSize = 50000;FILE *fd;char databuf[1024];int len;unsigned char TTL = 128;char one = 1;int cn = 0,ssent,i=0;FILE *fp;station *stations;int songsNumber = 0;void finish(char* s){	perror(s);	exit(1);}void UDP(char* songName){		struct sockaddr_in tmpIP;	// set content of struct saddr and imreq to zero	memset((char*)&saddr, 0, sizeof(struct sockaddr_in));    	memset(&iaddr, 0, sizeof(struct in_addr));		memset((char*)&tmpIP, 0, sizeof(struct sockaddr_in));	if(!((stations[songsNumber]).songFD = fopen(songName,"rb")))		finish("failed to open file \n");	else		printf("file opened \n");		saddr.sin_family = PF_INET;   	saddr.sin_port = htons(0); // Use the first free port 	saddr.sin_addr.s_addr = htonl(INADDR_ANY); // bind socket to any interface	//Temp sockaddr struct	tmpIP.sin_addr.s_addr = saddr.sin_addr.s_addr;	tmpIP.sin_family = PF_INET;	tmpIP.sin_port = htons(0);			//Open a UDP socket	if((stations[songsNumber].sd = socket(PF_INET,SOCK_DGRAM,0)) < 0)		finish("Error opening socket");	else		printf("Opening the datagram socket...OK.\n");			if(bind(stations[songsNumber].sd, (struct sockaddr *)&saddr, sizeof(struct sockaddr_in)) == -1)		finish("Error binding socket to interface");	else		printf("bind to interface...ok\n");			iaddr.s_addr = INADDR_ANY; // use DEFAULT interface		// Set the outgoing interface to DEFAULT   	setsockopt(stations[songsNumber].sd, IPPROTO_IP, IP_MULTICAST_IF, &iaddr, sizeof(struct in_addr));		// Set multicast packet TTL to 255	setsockopt(stations[songsNumber].sd, IPPROTO_IP, IP_MULTICAST_TTL, &TTL, sizeof(TTL));		// set destination multicast address   	tmpIP.sin_family = PF_INET;   	tmpIP.sin_addr.s_addr = inet_addr(DST_IP)+htonl(songsNumber);//saddr.sin_addr.s_addr + htonl(songsNumber);   	tmpIP.sin_port = htons(DST_PORT);		// join the multicast group   	setsockopt(stations[songsNumber].sd, IPPROTO_IP, IP_ADD_MEMBERSHIP,DST_IP, 15);	fp = popen("play-tmp3->/dev/null 2>&1","w");   //open a pipe. output is sent to dev/null 	songsNumber++;		while(1)	{		for(i = 0;i < songsNumber; i++)		{			if(feof(stations[i].songFD))				rewind(stations[i].songFD);	//if the song is over, start over			tmpIP.sin_addr.s_addr = (inet_addr(DST_IP)+htonl(i));// saddr.sin_addr.s_addr + htonl(i);						if((len = fread(databuf,1,1024,stations[i].songFD)) < 0)				finish("failed to read the file !!\n");						if(sendto(stations[i].sd,databuf,len,0,(struct sockaddr*)&tmpIP,(size_t)sizeof(tmpIP)) == -1)				finish("failed to send song !!\n");		}//for		waitTime.tv_sec=0;		waitTime.tv_nsec = 62500000;		nanosleep(&waitTime,NULL);	}//while	}int main (){	if(!(stations=(station*)malloc(sizeof(station)*100)))		finish("failed to allocate memory for stations");		char s1[] = "aa11.mp3";	char s2[] = "bb22.mp3";	char s3[] = "cc33.mp3";	char s4[] = "aa11.mp3";	char s5[] = "bb22.mp3";	char s6[] = "cc33.mp3";	UDP(s1);	UDP(s2);	UDP(s3);	UDP(s4);	UDP(s5);	UDP(s6);		return 0;}